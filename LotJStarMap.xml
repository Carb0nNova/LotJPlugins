<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE muclient> 
<!--  Saved on Thursday, July 05, 2012, 1:04 AM   --> 
<!-- MuClient version 4.73 --> 
<muclient>
<plugin name="LotJStarMap" author="@Johnson" id="dd5080a41939faabc233da8f" language="Lua" purpose="Star System Map" save_state="y" requires="4.73" version="2.15">
<description trim="y">
<![CDATA[ 
Type "hypmap" to find starsystems and plot on map.
Type "hidemap" to close map window, or click the X in the upper right to close.
Hover mouse over systems to see distances to other systems.
Click on a system to calculate a jump to the planet within that system.
  ]]> 
  </description>
  </plugin>
<!--   Get our standard constants   --> 
  <include name="constants.lua" /> 
<!--   Triggers    --> 
<triggers>
	<trigger name="systemCapture" script="storeSystem" match="^(.*)\( (.*)\, (.*) \)$" regexp="y" group="StarCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="starsFailed" script="toggleOff" match="^You must hold a datapad to do this\.$" regexp="y" group="StarCap" sequence="100" />
	<trigger name="systemCapDone" script="findPlanets" match="^Show what to whom\?$" regexp="y" group="StarCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="planetCapTitle" match="Planet*Starsystem*Governed By*Popular Support" enabled="n" group="PlanetCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="planetCapture" script="storePlanet" match="^(.*)\.\d$" regexp="y" enabled="n" group="PlanetCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="planetCapDone" script="setupWindow" match="^Use SHOWPLANET for more information\.$" regexp="y" enabled="n" group="PlanetCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<!-- Lightspeed triggers -->
	<trigger name="partialJump" match="^Remaining jump distance\: (.*)$" script="storePartialJump" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
	<trigger name="jumpComplete" match="^Hyperjump complete\.$" script="clearJump" group="LotJStarMap" enabled="y" regexp="y" sequence="100" />
	
  </triggers>
<!--   Aliases    --> 
<aliases>
  <alias name="initCommand" script="findStars" match="^hypmap$" enabled="y" regexp="y" group="LotJStarMap" sequence="100" />
  <alias name="removeWindow" script="destroyWindow" match="^hidemap$" enabled="y" regexp="y" group="LotJStarMap" sequence="100" />
  </aliases>
<timers>
	<timer name="hyperJumpTicker" script="hyperJumpTick" enabled="n" second="2" group="LotJStarMap" />
</timers>
<!--   Script    --> 
<script>
<![CDATA[ 

require "movewindow"
local win = "galaxy_map_" .. GetPluginID()  -- unique window name
local systems = {}
local system = { name = "", x = 0, y = 0, planet = "", left = 0, top = 0, right = 0, bottom = 0 }
local font = "f"
local maxX = 0
local minX = 0
local maxY = 0
local minY = 0
local smaxX = 0
local smaxY = 0
local sminX = 0
local sminY = 0
local failsafe = 0
local visible = false

-- hyperjump stuff
local totalJump = 0
local partialJump = 0
local startx = nil
local starty = nil
local realx = nil
local realy = nil

local msdp = {}

function storePlanet(name, list, args)
	--Note("1: '" .. args[1] .. "'")
	for i, v in ipairs(systems) do
		local sysName = v.name
		if (string.find(args[1], sysName)) then -- if the system name was found in the grab text
			systems[i].planet = Trim(string.sub(args[1], 1, string.find(args[1], sysName)-1)) -- set the planetname
			--Note("System: '" .. systems[i].name .. "' Planet: '" .. systems[i].planet .. "'")
		end
	end
end


function findStars(name, list, args)
	SendNoEcho("stars")
	SendNoEcho("show")
	toggleOn()
end

function findPlanets(name, list, args)
	SendNoEcho("planets")
	togglePlanetsOn()
end

function togglePlanetsOn(name, list, args)
	EnableTriggerGroup("PlanetCap", true)
end

function toggleOn(name, list, args)
	EnableTriggerGroup("StarCap", true)
	WindowCreate (win, 0, 0, 800, 600, miniwin.pos_center_all, 0, ColourNameToRGB("black"))  -- create window
	WindowFont (win, font, "Arial", 10, true, false, false, false) -- define font
end

require "tprint"

function storeSystem(name, list, args)
	if (args[1] and args[2] and args[3]) then
		system.name = Trim(args[1])
		system.x = tonumber(args[2])
		system.y = tonumber(args[3])
		systems[#systems + 1] = system
    system = { name = "", x = 0, y = 0, planet = "", left = 0, top = 0, right = 0, bottom = 0 }
	end
end

function toggleOff(name, list, args)
	EnableTriggerGroup("StarCap", false)
end

function togglePlanetsOff(name, list, args)
	EnableTriggerGroup("PlanetCap", false)
end

function setupWindow(name, line, args)
	toggleOff()
	togglePlanetsOff()
	
	-- find our real max and min values so we can scale accordingly
	for i=1,#systems,1 do
		local sys = systems[i]
		if (sys.x > maxX) then
			maxX = sys.x
		end
		if (sys.x < minX) then
		  minX = sys.x
		end
		if (sys.y > maxY) then
			maxY = sys.y
		end
		if (sys.y < minY) then
		  minY = sys.y
		end
	end	
	
	setupConflicts()
	
	visible = true
  drawWindow()
end

function setupConflicts()
  -- setup our text boundaries since we just now figured out our max and min values for scaling
  for i, v in ipairs(systems) do
  	v.left = scaleXCoord(v.x) - WindowTextWidth(win, "f", ((v.planet~="" and v.planet) or v.name))/2 + 5
		v.top = scaleYCoord(v.y) + 5
		v.right = v.left + WindowTextWidth(win, "f", ((v.planet~="" and v.planet) or v.name)) -- font width
		v.bottom = v.top + WindowFontInfo(win, "f", 1) -- font height
  end
  -- find our scaled max and mins
  smaxX = scaleXCoord(maxX)
  smaxY = scaleYCoord(maxY)
  sminX = scaleXCoord(minX)
  sminY = scaleYCoord(minY)
  --Note("maxX: "..maxX.." minX: "..minX.." maxY: "..maxY.." minY: "..minY)
  --Note("smaxX: "..smaxX.." sminX: "..sminX.." smaxY: "..smaxY.." sminY: "..sminY)
  
  -- recursively resolve conflicts with other systems
  failsafe = 0
  resolveConflicts()
end

function resolveConflicts()
  if failsafe <= 20 then -- we don't want to get stuck in an infinite recursion loop
  -- resolve window boundary conflicts
  for i, v in ipairs(systems) do
  --Note("system: "..v.name.." left: "..v.left.." top: "..v.top.." right: "..v.right.." bottom:"..v.bottom)
    if v.right > smaxX then
      v.left = smaxX - WindowTextWidth(win, "f", ((v.planet~="" and v.planet) or v.name))
      v.right = smaxX
    end
    if v.left < sminX then
      v.left = sminX
      v.right = v.left + WindowTextWidth(win, "f", ((v.planet~="" and v.planet) or v.name))
    end
    if v.bottom > sminY then
      v.top = sminY - WindowFontInfo(win, "f", 1) - 5
      v.bottom = sminY - 5
    end
  end
  -- resolve system conflicts
  for i, v in ipairs(systems) do
    for j, k in ipairs(systems) do
      if (i ~= j) then -- don't check a system against itself
        if conflicts(v, k) then -- uh oh we have a collision!
          failsafe = failsafe + 1
          resolveConflicts()
        end
      end
    end
  end
  end
end

-- this needs to be done better TODO
-- at the moment this works, but I am envisioning a system of 
-- calculating many different label positions, finding the
-- distance of the label from the marker, then choosing the label positions 
-- that maintain the best position for all systems in the vicinity
-- maybe it's overkill but if it's worth doing, it's worth overdoing.
function conflicts(sys1, sys2)
  if topleftconflicts(sys1, sys2) then
    --Note("Top Left Collision detected! ("..sys1.name..","..sys2.name..")")
    -- top left collided, try shifting down (add pixels)
    sys1.top = sys2.bottom + 1
    sys1.bottom = sys1.top + WindowFontInfo(win, "f", 1)
    return true
  elseif bottomleftconflicts(sys1, sys2) then
    --Note("Bottom Left Collision detected! ("..sys1.name..","..sys2.name..")")
    -- bottom left collided, try shifting the other guy down (add pixels)
    sys2.top = sys1.bottom + 1
    sys2.bottom = sys2.top + WindowFontInfo(win, "f", 1)
    return true
  elseif toprightconflicts(sys1, sys2) then
    --Note("Top Right Collision detected! ("..sys1.name..","..sys2.name..")")
    -- try shifting down first (add pixels)
    sys1.top = sys2.bottom + 1
    sys1.bottom = sys1.top + WindowFontInfo(win, "f", 1)
    return true
  elseif bottomrightconflicts(sys1, sys2) then
    --Note("Bottom Right Collision detected! ("..sys1.name..","..sys2.name..")")
    -- bottom right collided, try shifting the other guy down (add pixels)
    sys2.top = sys1.bottom + 1
    sys2.bottom = sys2.top + WindowFontInfo(win, "f", 1)
    return true
  else
    return false
  end
end

function topleftconflicts(s1, s2)
  return ((s1.left >= s2.left and s1.left <= s2.right) and (s1.top <= s2.bottom and s1.top >= s2.top))
end

function bottomleftconflicts(s1, s2)
  return ((s1.left >= s2.left and s1.left <= s2.right) and (s1.bottom <= s2.bottom and s1.bottom >= s2.top))
end

function toprightconflicts(s1, s2)
  return ((s1.right >= s2.left and s1.right <= s2.right) and (s1.top <= s2.bottom and s1.top >= s2.top))
end

function bottomrightconflicts(s1, s2)
  return ((s1.right >= s2.left and s1.right <= s2.right) and (s1.bottom <= s2.bottom and s1.bottom >= s2.top))
end

function drawWindow(name, line, args)

	WindowRectOp (win, miniwin.rect_fill, 0, 0, 800, 600, ColourNameToRGB("black"))  -- draw blank rectangle to "erase" window contents

	for i=1,#systems,1 do
		local sys = systems[i]
		local x = scaleXCoord(sys.x)  -- scale X coordinate
		local y = scaleYCoord(sys.y) -- scale Y coordinate
		
		WindowText (win, "f", ((sys.planet~="" and sys.planet) or sys.name),   -- text
                sys.left, sys.top, sys.right, sys.bottom,        -- rectangle
                ColourNameToRGB ("white"), -- colour
                false)              -- not Unicode
                
    	WindowCircleOp (win, miniwin.circle_ellipse, -- circle
                x-5, y-5, x+5, y+5,                -- Left, Top, Right, Bottom
                ColourNameToRGB("lawngreen"), miniwin.pen_solid, 1, -- pen width 1
                ColourNameToRGB("lawngreen"), miniwin.brush_solid)  -- brush
        
        WindowAddHotspot(win, i,  
                -- x, y, WindowTextWidth (win, "f", tostring(sys.name)), WindowFontInfo (win, "f", 1),   -- rectangle, left, top, right, bottom
                 sys.left, sys.top, sys.right, sys.bottom,
                 "drawPaths", -- mousehover
                 "hidePaths",        -- mousecancelhover
                 "onClick",         -- mousedown
                 "",   -- mousecanceldown
                 "",           -- mouseup
                 sys.name.. " (" .. sys.x .. "," .. sys.y .. ")",  -- tooltip text
                 1, 0)
    end

	 -- draw border
  	WindowRectOp (win, 5, 0, 0, 0, 0, 5, 15 + 0x1000)
  
  	-- add the drag handler so they can move the window around
  	local font_height = WindowFontInfo (win, font, 1)
  	movewindow.add_drag_handler (win, 0, 0, 0, font_height)
  	
  	-- draw X in the corner to close the window
  	WindowLine (win, 785, 5, 795, 15, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  	WindowLine (win, 785, 15, 795, 5, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  	WindowAddHotspot(win, "windowX",
  			785, 5, 795, 15,
  			"",                   --mousehover
  			"",                   --mouseoffhover
  			"destroyWindow",      --mousedown
  			"",                   --mouseoffdown
  			"",                   --mouseup
  			"Close hypmap window",
  			1, 0)
  
  	-- heading line
 	WindowText (win, font, "Galaxy Map", 5, 5, 0, 0, ColourNameToRGB  "white")
 	
  drawHyperpath()
  WindowShow (win,  true)  -- show it
  	--BroadcastPlugin(999, "repaint")
end

function drawHyperpath()
	if haveCoords() then
	  drawCoords()
	end
	
	if haveDestination() then
	  drawRoute()
	end
end

function haveCoords()
  local currentX = tonumber(getmsdp("SHIPGALX") or 0)
  local currentY = tonumber(getmsdp("SHIPGALY") or 0)
  local currentSystem = getmsdp("SHIPSYSNAME")
  local currentPlanet = getmsdp("PLANET")
  
  if ((currentX ~= 0 and currentY ~= 0) and (currentSystem ~= "" or currentPlanet ~= "")) then
    return true
  end
  return false
end
function drawCoords()
  local curX = tonumber(getmsdp("SHIPGALX") or 0)
  local curY = tonumber(getmsdp("SHIPGALY") or 0)
  local curSystem = getmsdp("SHIPSYSNAME")
  local curPlanet = getmsdp("PLANET")
  
  if curX ~= 0 and curY ~= 0 then
    realx = scaleXCoord(curX)
    realy = scaleYCoord(curY)
    WindowCircleOp(win, 1, realx-3, realy-3, realx+3, realy+3, ColourNameToRGB("red"), 0, 0, ColourNameToRGB("red"), 0)
  else
    for k, v in pairs(systems) do
      if curSystem ~= "" and (string.lower(v.name) == string.lower(curSystem)) then
        realx = scaleXCoord(v.x)
        realy = scaleYCoord(v.y)
        WindowCircleOp(win, 1, realx-3, realy-3, realx+3, realy+3, ColourNameToRGB("red"), 0, 0, ColourNameToRGB("red"), 0)
      elseif curPlanet ~= "" and (string.lower(v.planet) == string.lower(curPlanet)) then
        realx = scaleXCoord(v.x)
        realy = scaleYCoord(v.y)
        WindowCircleOp(win, 1, realx-3, realy-3, realx+3, realy+3, ColourNameToRGB("red"), 0, 0, ColourNameToRGB("red"), 0)
      end
    end
  end
end
function haveDestination()
  local storedsystem = GetPluginVariable("b2c06b3dcc775c0ede861316", "planetname") or ""
  
  for k, v in pairs(systems) do
    if storedsystem ~= "" and ((string.lower(v.name) == string.lower(storedsystem)) or (string.lower(v.planet) == string.lower(storedsystem))) then
      if realx ~= nil and realy ~= nil then
        return true
      end
    end
  end
  return false
end
function drawRoute()
  local storedsystem = GetPluginVariable("b2c06b3dcc775c0ede861316", "planetname") or ""
  local endX = 0
  local endY = 0
  
	local percent = 0
	local pixels = 0
	
	if (totalJump > 0 and partialJump > 0) then
		percent = (totalJump - partialJump) / totalJump
	end
  
  -- find our ending location
  for k, v in pairs(systems) do
    if storedsystem ~= "" and ((string.lower(v.name) == string.lower(storedsystem)) or (string.lower(v.planet) == string.lower(storedsystem))) then
      endX = scaleXCoord(v.x)
      endY = scaleYCoord(v.y)
    end
  end
  -- find our starting position to draw a line from
  if startx == nil and starty == nil then
    startx = realx
    starty = realy
  end
  -- draw our route and place on that route
  WindowLine(win, startx, starty, endX, endY, ColourNameToRGB("white"), miniwin.pen_solid, 2)
  WindowCircleOp(win, 1, (((1-percent)*startx)+(percent*endX))-3, (((1-percent)*starty)+(percent*endY))-3, (((1-percent)*startx)+(percent*endX))+3, (((1-percent)*starty)+(percent*endY))+3, ColourNameToRGB("red"), 0, 0, ColourNameToRGB("red"), 0)
end

function togglePaths(flags, hotspot_id)
	if(showPaths == true) then
		showPaths = false
		hidePaths()
	else
		showPaths = true
		drawPaths(flags, hotspotid)
	end
end


function hidePaths(flags, hotspot_id)
	WindowRectOp (win, miniwin.rect_fill, 0, 0, 800, 600, ColourNameToRGB("black"))  -- draw blank rectangle to "erase" window contents
	drawWindow() -- redraw window
	
end

function scaleXCoord(coord)
  if coord > 0 then
    return ((( coord / maxX) * 400) + 390)
  else
    return (410 - (( coord / minX) * 400))
  end
end

function scaleYCoord(coord)
  if coord > 0 then
  	return (300 - ((( coord / maxY) * 300)-10))
  else
    return (300 + ((( coord / minY) * 300)-10))
  end
end

function onClick(flags, hotspot_id)
	local sys = systems[tonumber(hotspot_id)]
	if (sys.planet ~= "") then
		Execute("calculate " .. sys.planet)
	else
		Execute("calcu '" .. sys.x .. " " .. sys.y .. "'")
	end
end

function drawPaths(flags, hotspot_id)
	local sys = systems[tonumber(hotspot_id)]
	if not sys then
		return
	end
	local ax = scaleXCoord(tonumber(sys.x))
	local ay = scaleYCoord(tonumber(sys.y))
	for i, v in ipairs(systems) do
		if (v ~= sys) then
			local bx = scaleXCoord(tonumber(v.x))
			local by = scaleYCoord(tonumber(v.y))
			WindowLine (win, ax, ay, bx, by, ColourNameToRGB ("orange"), miniwin.pen_solid, 1)
			WindowText (win, "f", distance(sys, v),   -- text
                (ax+bx)/2, (ay+by)/2, 0, 0,        --draw distance in the middle of draw path
                ColourNameToRGB ("white"), -- colour
                false)              -- not Unicode
			
		end
	end
	WindowShow (win,  true)  -- show it
		--BroadcastPlugin(999, "repaint")

end

function destroyWindow(name, list, args)
	systems = {}
	system = { }
	WindowShow (win, false)
	visible = false
	--WindowDelete(win)
end

function distance(a, b)
	return string.format("%.0f", math.sqrt(((a.x-b.x)*(a.x-b.x))+((a.y-b.y)*(a.y-b.y))))
end

function hyperJumpTick()
	if (totalJump > 0 and partialJump > 0) then
		partialJump = partialJump - 50
		if (visible) then
			--Note("Tick: " .. partialJump .. "/" .. totalJump)
			drawWindow()
		end
	end
end

function storeTotalJump(name, list, args)
	if (args[1] and tonumber(args[1]) > 0) then
		totalJump = tonumber(args[1])
	end
	if (visible) then
		drawWindow()
	end
end

function storePartialJump(name, list, args)
	if (args[1] and tonumber(args[1]) > 0) then
		if (totalJump == 0) then
			totalJump = tonumber(args[1])
			EnableTimer("hyperJumpTicker", true)
		end
		partialJump = tonumber(args[1])
	end
	if (visible) then
		--Note("Tock: " .. partialJump .. "/" .. totalJump)
		drawWindow()
	end
end

function clearJump()
  startx = nil
  starty = nil
  realx = nil
  realy = nil
	totalJump = 0
	partialJump = 0
	EnableTimer("hyperJumpTicker", false)
	if (visible) then
		drawWindow()
	end
end


--============================================================================
-- Central function for listening to data broadcast by LotJMSDPHandler.xml
-- Stores broadcast information locally to be easily accessed by plugin
--============================================================================

function OnPluginBroadcast (msg, id, name, text)
	-- Look for MSDP Handler.
	if (id == 'b3aae34498d5bf19b5b2e2af') then
		-- HUGE FIXME.. not an idea solution
		if (msg == 91) then -- we got table information from MSDP handler
			-- store information in our own msdp table
			key = string.sub(text, 0, string.find(text,",",0,true)-1)  -- parse the variable key
			val = utils.base64decode(string.sub(text, string.find(text,",",0,true)+1, string.len(text))) -- parse the variable value
			msdp[key] = val -- store it
			--Note("key: " .. key .. " val: " .. msdp[key])
			key = ""
			val = ""
		end
	end
	if visible then
	  drawWindow()  -- redraw windows every time new information is received
	  --BroadcastPlugin(999, "repaint")
	end
end

--============================================================================
-- Function to be used to retrieve msdp information. Returns either the
-- information stored in the local msdp table or gets the requested variable
-- from msdp_helper, if it doesn't exist locally
--============================================================================

function getmsdp(key)
	if not IsConnected() then  -- don't try to get stuff if we aren't connected to the mud
		return ""
	end
	if (msdp[key] ~= nil) then  -- if the key has been updated by msdp handler already, retrieve it
		return msdp[key]
	elseif (GetPluginVariable("b3aae34498d5bf19b5b2e2af", key) ~= nil) then  -- if the key hasn't been updated, but msdp handler has it cached, retrieve it and store in local table for next time
		msdp[key] = utils.base64decode(GetPluginVariable("b3aae34498d5bf19b5b2e2af", key))
		return msdp[key]
	else
		ColourNote("red","black", "Warning: Unable to find key " .. key)
		return ""   -- should never get here  -- can't find the requested key
	end
	return "" -- should never ever get here
end

function OnPluginInstall ()

  -- install the window movement handler, get back the window position
  windowinfo = movewindow.install (win, 6)  -- default to 6 (on top right)
  
  -- make window so I can grab the font info
  WindowCreate (win, 0, 0, 0, 0, 1, 0, 0)

  -- add the font                 
  WindowFont (win, font, "Courier", 10)  
    
end -- OnPluginInstall

function OnPluginSaveState ()
  -- save window current location for next time  
  movewindow.save_state (win)
end -- function OnPluginSaveState

require "checkplugin"
function OnPluginListChanged()
	do_plugin_check_now ("b3aae34498d5bf19b5b2e2af", "LotJMSDPHandler") -- check we have MSDP handler plugin
	do_plugin_check_now ("b2c06b3dcc775c0ede861316", "LotJCalc") -- check we have LotJCalc
end

  ]]> 
  </script>
  </muclient>