<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE muclient> 
<!--  Saved on Thursday, July 05, 2012, 1:04 AM   --> 
<!-- MuClient version 4.73 --> 
<muclient>
<plugin name="LotJStarMap" author="@Johnson" id="dd5080a41939faabc233da8f" language="Lua" purpose="Star System Map" save_state="y" requires="4.73" version="2.13">
<description trim="y">
<![CDATA[ 
Type "hypmap" to find starsystems and plot on map.
Type "hidemap" to close map window, or click the X in the upper right to close.
Hover mouse over systems to see distances to other systems.
Click on a system to calculate a jump to the planet within that system.
  ]]> 
  </description>
  </plugin>
<!--   Get our standard constants   --> 
  <include name="constants.lua" /> 
<!--   Triggers    --> 
<triggers>
	<trigger name="systemCapture" script="storeSystem" match="^(.*)\( (.*)\, (.*) \)$" regexp="y" group="StarCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="starsFailed" script="toggleOff" match="^You must hold a datapad to do this\.$" regexp="y" group="StarCap" sequence="100" />
	<trigger name="systemCapDone" script="findPlanets" match="^Show what to whom\?$" regexp="y" group="StarCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="planetCapTitle" match="Planet*Starsystem*Governed By*Popular Support" enabled="n" group="PlanetCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="planetCapture" script="storePlanet" match="^(.*)\.\d$" regexp="y" enabled="n" group="PlanetCap" omit_from_log="y" omit_from_output="y" sequence="100" />
	<trigger name="planetCapDone" script="setupWindow" match="^Use SHOWPLANET for more information\.$" regexp="y" enabled="n" group="PlanetCap" omit_from_log="y" omit_from_output="y" sequence="100" />

  </triggers>
<!--   Aliases    --> 
<aliases>
  <alias name="initCommand" script="findStars" match="^hypmap$" enabled="y" regexp="y" group="LotJStarMap" sequence="100" />
  <alias name="removeWindow" script="destroyWindow" match="^hidemap$" enabled="y" regexp="y" group="LotJStarMap" sequence="100" />
  </aliases>
<!--   Script    --> 
<script>
<![CDATA[ 

require "movewindow"
win = "galaxy_map_" .. GetPluginID()  -- unique window name
systems = {}
system = { name = "", x = 0, y = 0, planet = "", left = 0, top = 0, right = 0, bottom = 0 }
font = "f"
maxX = 0
minX = 0
maxY = 0
minY = 0
smaxX = 0
smaxY = 0
sminX = 0
sminY = 0
failsafe = 0

function storePlanet(name, list, args)
	--Note("1: '" .. args[1] .. "'")
	for i, v in ipairs(systems) do
		local sysName = v.name
		if (string.find(args[1], sysName)) then -- if the system name was found in the grab text
			systems[i].planet = Trim(string.sub(args[1], 1, string.find(args[1], sysName)-1)) -- set the planetname
			--Note("System: '" .. systems[i].name .. "' Planet: '" .. systems[i].planet .. "'")
		end
	end
end


function findStars(name, list, args)
	SendNoEcho("stars")
	SendNoEcho("show")
	toggleOn()
end

function findPlanets(name, list, args)
	SendNoEcho("planets")
	togglePlanetsOn()
end

function togglePlanetsOn(name, list, args)
	EnableTriggerGroup("PlanetCap", true)
end

function toggleOn(name, list, args)
	EnableTriggerGroup("StarCap", true)
	WindowCreate (win, 0, 0, 800, 600, miniwin.pos_center_all, 0, ColourNameToRGB("black"))  -- create window
	WindowFont (win, font, "Arial", 10, true, false, false, false) -- define font
end

require "tprint"

function storeSystem(name, list, args)
	if (args[1] and args[2] and args[3]) then
		system.name = Trim(args[1])
		system.x = tonumber(args[2])
		system.y = tonumber(args[3])
		systems[#systems + 1] = system
    system = { name = "", x = 0, y = 0, planet = "", left = 0, top = 0, right = 0, bottom = 0 }
	end
end

function toggleOff(name, list, args)
	EnableTriggerGroup("StarCap", false)
end

function togglePlanetsOff(name, list, args)
	EnableTriggerGroup("PlanetCap", false)
end

function setupWindow(name, line, args)
	toggleOff()
	togglePlanetsOff()
	
	-- find our real max and min values so we can scale accordingly
	for i=1,#systems,1 do
		local sys = systems[i]
		if (sys.x > maxX) then
			maxX = sys.x
		end
		if (sys.x < minX) then
		  minX = sys.x
		end
		if (sys.y > maxY) then
			maxY = sys.y
		end
		if (sys.y < minY) then
		  minY = sys.y
		end
	end	
	
	
	setupConflicts()
	
  drawWindow()
end

function setupConflicts()
  -- setup our text boundaries since we just now figured out our max and min values for scaling
  for i, v in ipairs(systems) do
  	v.left = scaleXCoord(v.x) - WindowTextWidth(win, "f", ((v.planet~="" and v.planet) or v.name))/2 + 5
		v.top = scaleYCoord(v.y) + 5
		v.right = v.left + WindowTextWidth(win, "f", ((v.planet~="" and v.planet) or v.name)) -- font width
		v.bottom = v.top + WindowFontInfo(win, "f", 1) -- font height
  end
  -- find our scaled max and mins
  smaxX = scaleXCoord(maxX)
  smaxY = scaleYCoord(maxY)
  sminX = scaleXCoord(minX)
  sminY = scaleYCoord(minY)
  --Note("maxX: "..maxX.." minX: "..minX.." maxY: "..maxY.." minY: "..minY)
  --Note("smaxX: "..smaxX.." sminX: "..sminX.." smaxY: "..smaxY.." sminY: "..sminY)
  
  -- recursively resolve conflicts with other systems
  failsafe = 0
  resolveConflicts()
end

function resolveConflicts()
  if failsafe <= 20 then -- we don't want to get stuck in an infinite recursion loop
  -- resolve window boundary conflicts
  for i, v in ipairs(systems) do
  --Note("system: "..v.name.." left: "..v.left.." top: "..v.top.." right: "..v.right.." bottom:"..v.bottom)
    if v.right > smaxX then
      v.left = smaxX - WindowTextWidth(win, "f", ((v.planet~="" and v.planet) or v.name))
      v.right = smaxX
    end
    if v.left < sminX then
      v.left = sminX
      v.right = v.left + WindowTextWidth(win, "f", ((v.planet~="" and v.planet) or v.name))
    end
    if v.bottom > sminY then
      v.top = sminY - WindowFontInfo(win, "f", 1) - 5
      v.bottom = sminY - 5
    end
  end
  -- resolve system conflicts
  for i, v in ipairs(systems) do
    for j, k in ipairs(systems) do
      if (i ~= j) then -- don't check a system against itself
        if conflicts(v, k) then -- uh oh we have a collision!
          failsafe = failsafe + 1
          resolveConflicts()
        end
      end
    end
  end
  end
end

-- this needs to be done better TODO
-- at the moment this works, but I am envisioning a system of 
-- calculating many different label positions, finding the
-- distance of the label from the marker, then choosing the label positions 
-- that maintain the best position for all systems in the vicinity
-- maybe it's overkill but if it's worth doing, it's worth overdoing.
function conflicts(sys1, sys2)
  if topleftconflicts(sys1, sys2) then
    --Note("Top Left Collision detected! ("..sys1.name..","..sys2.name..")")
    -- top left collided, try shifting down (add pixels)
    sys1.top = sys2.bottom + 1
    sys1.bottom = sys1.top + WindowFontInfo(win, "f", 1)
    return true
  elseif bottomleftconflicts(sys1, sys2) then
    --Note("Bottom Left Collision detected! ("..sys1.name..","..sys2.name..")")
    -- bottom left collided, try shifting the other guy down (add pixels)
    sys2.top = sys1.bottom + 1
    sys2.bottom = sys2.top + WindowFontInfo(win, "f", 1)
    return true
  elseif toprightconflicts(sys1, sys2) then
    --Note("Top Right Collision detected! ("..sys1.name..","..sys2.name..")")
    -- try shifting down first (add pixels)
    sys1.top = sys2.bottom + 1
    sys1.bottom = sys1.top + WindowFontInfo(win, "f", 1)
    return true
  elseif bottomrightconflicts(sys1, sys2) then
    --Note("Bottom Right Collision detected! ("..sys1.name..","..sys2.name..")")
    -- bottom right collided, try shifting the other guy down (add pixels)
    sys2.top = sys1.bottom + 1
    sys2.bottom = sys2.top + WindowFontInfo(win, "f", 1)
    return true
  else
    return false
  end
end

function topleftconflicts(s1, s2)
  return ((s1.left >= s2.left and s1.left <= s2.right) and (s1.top <= s2.bottom and s1.top >= s2.top))
end

function bottomleftconflicts(s1, s2)
  return ((s1.left >= s2.left and s1.left <= s2.right) and (s1.bottom <= s2.bottom and s1.bottom >= s2.top))
end

function toprightconflicts(s1, s2)
  return ((s1.right >= s2.left and s1.right <= s2.right) and (s1.top <= s2.bottom and s1.top >= s2.top))
end

function bottomrightconflicts(s1, s2)
  return ((s1.right >= s2.left and s1.right <= s2.right) and (s1.bottom <= s2.bottom and s1.bottom >= s2.top))
end

function drawWindow(name, line, args)
	
	for i=1,#systems,1 do
		local sys = systems[i]
		local x = scaleXCoord(sys.x)  -- scale X coordinate
		local y = scaleYCoord(sys.y) -- scale Y coordinate
		
		WindowText (win, "f", ((sys.planet~="" and sys.planet) or sys.name),   -- text
                sys.left, sys.top, sys.right, sys.bottom,        -- rectangle
                ColourNameToRGB ("white"), -- colour
                false)              -- not Unicode
                
    	WindowCircleOp (win, miniwin.circle_ellipse, -- circle
                x-5, y-5, x+5, y+5,                -- Left, Top, Right, Bottom
                ColourNameToRGB("lawngreen"), miniwin.pen_solid, 1, -- pen width 1
                ColourNameToRGB("lawngreen"), miniwin.brush_solid)  -- brush
        
        WindowAddHotspot(win, i,  
                -- x, y, WindowTextWidth (win, "f", tostring(sys.name)), WindowFontInfo (win, "f", 1),   -- rectangle, left, top, right, bottom
                 sys.left, sys.top, sys.right, sys.bottom,
                 "drawPaths", -- mousehover
                 "hidePaths",        -- mousecancelhover
                 "onClick",         -- mousedown
                 "",   -- mousecanceldown
                 "",           -- mouseup
                 sys.name.. " (" .. sys.x .. "," .. sys.y .. ")",  -- tooltip text
                 1, 0)
                
    end

	 -- draw border
  	WindowRectOp (win, 5, 0, 0, 0, 0, 5, 15 + 0x1000)
  
  	-- add the drag handler so they can move the window around
  	local font_height = WindowFontInfo (win, font, 1)
  	movewindow.add_drag_handler (win, 0, 0, 0, font_height)
  	
  	-- draw X in the corner to close the window
  	WindowLine (win, 785, 5, 795, 15, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  	WindowLine (win, 785, 15, 795, 5, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  	WindowAddHotspot(win, "windowX",
  			785, 5, 795, 15,
  			"",                   --mousehover
  			"",                   --mouseoffhover
  			"destroyWindow",      --mousedown
  			"",                   --mouseoffdown
  			"",                   --mouseup
  			"Close hypmap window",
  			1, 0)
  
  	-- heading line
 	WindowText (win, font, "Galaxy Map", 5, 5, 0, 0, ColourNameToRGB  "white")
  
  
  	WindowShow (win,  true)  -- show it
  
end

function togglePaths(flags, hotspot_id)
	if(showPaths == true) then
		showPaths = false
		hidePaths()
	else
		showPaths = true
		drawPaths(flags, hotspotid)
	end
end


function hidePaths(flags, hotspot_id)
	WindowRectOp (win, miniwin.rect_fill, 0, 0, 800, 600, ColourNameToRGB("black"))  -- draw blank rectangle to "erase" window contents
	drawWindow() -- redraw window
	
end

function scaleXCoord(coord)
  if coord > 0 then
    return ((( coord / maxX) * 400) + 390)
  else
    return (410 - (( coord / minX) * 400))
  end
end

function scaleYCoord(coord)
  if coord > 0 then
  	return (300 - ((( coord / maxY) * 300)-10))
  else
    return (300 + ((( coord / minY) * 300)-10))
  end
end

function onClick(flags, hotspot_id)
	local sys = systems[tonumber(hotspot_id)]
	if (sys.planet ~= "") then
		Execute("calculate " .. sys.planet)
	else
		Execute("calcu '" .. sys.x .. " " .. sys.y .. "'")
	end
end

function drawPaths(flags, hotspot_id)
	local sys = systems[tonumber(hotspot_id)]
	if not sys then
		return
	end
	local ax = scaleXCoord(tonumber(sys.x))
	local ay = scaleYCoord(tonumber(sys.y))
	for i, v in ipairs(systems) do
		if (v ~= sys) then
			local bx = scaleXCoord(tonumber(v.x))
			local by = scaleYCoord(tonumber(v.y))
			WindowLine (win, ax, ay, bx, by, ColourNameToRGB ("orange"), miniwin.pen_solid, 1)
			WindowText (win, "f", distance(sys, v),   -- text
                (ax+bx)/2, (ay+by)/2, 0, 0,        --draw distance in the middle of draw path
                ColourNameToRGB ("white"), -- colour
                false)              -- not Unicode
			
		end
	end
	WindowShow (win,  true)  -- show it

end

function destroyWindow(name, list, args)
	systems = {}
	system = { }
	WindowShow (win, false)
	--WindowDelete(win)
end

function distance(a, b)
	return string.format("%.0f", math.sqrt(((a.x-b.x)*(a.x-b.x))+((a.y-b.y)*(a.y-b.y))))
end


function OnPluginInstall ()

  -- install the window movement handler, get back the window position
  windowinfo = movewindow.install (win, 6)  -- default to 6 (on top right)
  
  -- make window so I can grab the font info
  WindowCreate (win, 0, 0, 0, 0, 1, 0, 0)

  -- add the font                 
  WindowFont (win, font, "Courier", 10)  
    
end -- OnPluginInstall

function OnPluginSaveState ()
  -- save window current location for next time  
  movewindow.save_state (win)
end -- function OnPluginSaveState


  ]]> 
  </script>
  </muclient>